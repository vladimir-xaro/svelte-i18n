import{derived as h,readonly as p,writable as w}from"svelte/store";import g from"isobject";import x from"deepmerge";const c=(()=>{const{set:n,subscribe:r}=w(null);let s=null;r(t=>{s=t});const a=t=>{if(t!==s){if(t===null){n(null);return}if(!(t in o))throw new Error(`[@xaro/svelte-i18n] No translations for locale: "${t}"`);n(t)}};return{set:a,update:t=>a(t(s)),subscribe:r,setNullIf:t=>{s!==null&&t===s&&a(t)}}})();let b={};const y=w(b);y.subscribe(n=>b=n);const T=w(new Set),L=p(T),o={};window.allTranslations=o;const N=n=>{if(n){if("translations"in n){if(!g(n.translations))throw new Error("[@xaro/svelte-i18n] options.translations must be an object if passed");Object.assign(o,n.translations),T.update(r=>{for(const s in n.translations)r.add(s);return r})}if("defaultTranslations"in n){if(!g(n.defaultTranslations))throw new Error("[@xaro/svelte-i18n] options.defaultTranslations must be an object if passed");Object.keys(n.defaultTranslations).length&&y.update(r=>(Object.assign(r,n.defaultTranslations),r))}if("locale"in n){if(typeof n.locale!="string")throw new Error(`[@xaro/svelte-i18n] options.locale must be a string, ${typeof n.locale} passed`);if(!(n.locale in o))throw new Error(`[@xaro/svelte-i18n] No translations for locale: ${n.locale}`);c.set(n.locale)}}},O=n=>n in o,k=n=>n in o?(delete o[n],c.setNullIf(n),!0):!1,m=(n,r,s,a=!1)=>{n in o||(o[n]={},T.update(t=>t.add(n)));let l=Array.isArray(r)?r:r.split(/\.+/);if(!l.length){if(!g(s))throw new Error("[@xaro/svelte-i18n] Translation cannot be a string when no path is given");o[n]=s;return}let e=o[n];for(let t=0;t<l.length;t++){const i=l[t];if(i)t===l.length-1?e[i]=s:(i in e||(e[i]={}),e=e[i]);else throw new Error("[@xaro/svelte-i18n] Path cannot be empty, end or begin with a separator character")}a&&c.set(n)},I=(n,r,s,a=!1)=>{if(!(n in o)){m(n,r,s);return}let l=Array.isArray(r)?r:r.split(/\.+/);if(!l.length){if(!g(s))throw new Error("[@xaro/svelte-i18n] Translation cannot be a string when no path is given");o[n]=s;return}let e=o[n];for(let t=0;t<l.length;t++){const i=l[t];if(i)t===l.length-1?i in e&&g(e[i])&&g(s)?e[i]=x(e[i],s):e[i]=s:(i in e||(e[i]={}),e=e[i]);else throw new Error("[@xaro/svelte-i18n] Path cannot be empty, end or begin with a separator character")}a&&c.set(n)},S=(n,r,s=!1)=>{if(!(n in o))throw new Error(`[@xaro/svelte-i18n] No translations for locale: ${n}`);let a=o[n],l=Array.isArray(r)?r:r.split(/\.+/);for(let e=0;e<l.length;e++){const t=l[e];if(t)e===l.length-1?delete a[t]:(t in a||(a[t]={}),a=a[t]);else throw new Error("[@xaro/svelte-i18n] Path cannot be empty, end or begin with a separator character")}s&&c.set(n)},v=(n,r,s,a)=>{const l=()=>a||(n&&n in b?b[n]:Array.isArray(r)?r.join(","):r);if(n===null||!(n in o))return l();let e=o[n];const t=i=>{if(typeof e[i]=="string"){let f=e[i];if(g(s)){const u=Object.keys(s);if(u.length)for(const d of u)f=f.replaceAll(`{{${d}}}`,s[d])}return f}return e=e[i],null};if(Array.isArray(r))n:for(const i of r)if(i in e){const f=t(i);if(f!==null)return f}else{const f=i.split(".");for(f.splice(-1);f.length;)if(f.join(".")in e){const d=t(i);if(d!==null)return d;continue n}else f.splice(-1);return l()}else{const i=r.split(".");for(const f of i)if(f in e){const u=t(f);if(u!==null)return u}else return a||r}return l()},W=h(c,n=>(r,s={},a)=>v(n,r,s,a));export{I as addTranslation,L as allLocales,O as hasLocale,N as init,c as locale,k as removeLocale,S as removeTranslation,m as setTranslation,W as t};
//# sourceMappingURL=svelte-i18n.mjs.map
