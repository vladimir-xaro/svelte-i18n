import{derived as h,readonly as p,writable as w}from"svelte/store";import c from"isobject";import x from"deepmerge";const u=(()=>{const{set:n,subscribe:r}=w(null);let s=null;r(t=>{s=t});const o=t=>{if(t!==s){if(t===null){n(null);return}if(!(t in l))throw new Error(`[@xaro/svelte-i18n] No translations for locale: "${t}"`);n(t)}};return{set:o,update:t=>o(t(s)),subscribe:r,setNullIf:t=>{s!==null&&t===s&&o(t)}}})();let b={};const y=w(b);y.subscribe(n=>b=n);const T=w(new Set),N=p(T),l={};window.allTranslations=l;const O=n=>{if(n){if("translations"in n){if(!c(n.translations))throw new Error("[@xaro/svelte-i18n] options.translations must be an object if passed");Object.assign(l,n.translations),T.update(r=>{for(const s in n.translations)r.add(s);return r})}if("defaultTranslations"in n){if(!c(n.defaultTranslations))throw new Error("[@xaro/svelte-i18n] options.defaultTranslations must be an object if passed");Object.keys(n.defaultTranslations).length&&y.update(r=>(Object.assign(r,n.defaultTranslations),r))}if("locale"in n){if(typeof n.locale!="string")throw new Error(`[@xaro/svelte-i18n] options.locale must be a string, ${typeof n.locale} passed`);if(!(n.locale in l))throw new Error(`[@xaro/svelte-i18n] No translations for locale: ${n.locale}`);u.set(n.locale)}}},_=n=>n in l,k=n=>n in l?(delete l[n],u.setNullIf(n),!0):!1,v=(n,r,s,o=!1)=>{n in l||(l[n]={},T.update(t=>t.add(n)));let a=Array.isArray(r)?r:r.split(/\.+/);if(!a.length){if(!c(s))throw new Error("[@xaro/svelte-i18n] Translation cannot be a string when no path is given");l[n]=s;return}let e=l[n];for(let t=0;t<a.length;t++){const i=a[t];if(i)t===a.length-1?e[i]=s:(i in e||(e[i]={}),e=e[i]);else throw new Error("[@xaro/svelte-i18n] Path cannot be empty, end or begin with a separator character")}o&&u.set(n)},I=(n,r,s,o=!1)=>{if(!(n in l)){v(n,r,s);return}let a=Array.isArray(r)?r:r.split(/\.+/);if(!a.length){if(!c(s))throw new Error("[@xaro/svelte-i18n] Translation cannot be a string when no path is given");l[n]=s;return}let e=l[n];for(let t=0;t<a.length;t++){const i=a[t];if(i)t===a.length-1?i in e&&c(e[i])&&c(s)?e[i]=x(e[i],s):e[i]=s:(i in e||(e[i]={}),e=e[i]);else throw new Error("[@xaro/svelte-i18n] Path cannot be empty, end or begin with a separator character")}o&&u.set(n)},S=(n,r,s=!1)=>{if(!(n in l))throw new Error(`[@xaro/svelte-i18n] No translations for locale: ${n}`);let o=l[n],a=Array.isArray(r)?r:r.split(/\.+/);for(let e=0;e<a.length;e++){const t=a[e];if(t)e===a.length-1?delete o[t]:(t in o||(o[t]={}),o=o[t]);else throw new Error("[@xaro/svelte-i18n] Path cannot be empty, end or begin with a separator character")}s&&u.set(n)},m=(n,r,s,o)=>{const a=()=>o||(n&&n in b?b[n]:Array.isArray(r)?r.join(","):r);if(n===null||!(n in l))return a();let e=l[n];const t=i=>{if(typeof e[i]=="string"){let f=e[i];if(c(s)){const g=Object.keys(s);if(g.length)for(const d of g)f=f.replaceAll(`{{${d}}}`,s[d])}return f}return e=e[i],null};if(Array.isArray(r))n:for(const i of r)if(i in e){const f=t(i);if(f!==null)return f}else{const f=i.split(/\.+/);for(f.splice(-1);f.length;){const g=f.join(".");if(g in e){const d=t(g);if(d!==null)return d;continue n}else f.splice(-1)}return a()}else{const i=r.split(/\.+/);for(const f of i)if(f in e){const g=t(f);if(g!==null)return g}else return a()}return a()},W=h(u,n=>(r,s={},o)=>m(n,r,s,o));export{I as addTranslation,N as allLocales,_ as hasLocale,O as init,u as locale,k as removeLocale,S as removeTranslation,v as setTranslation,W as t};
//# sourceMappingURL=svelte-i18n.mjs.map
